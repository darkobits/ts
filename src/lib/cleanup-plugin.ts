import path from 'node:path'

import chalk from 'chalk'
import fs from 'fs-extra'

import log from './log'

import type { Plugin } from 'vite'

interface CleanupPluginOptions {
  /**
   * Root directory that the plugin will operate on. This should be set to the
   * project's output directory.
  */
 root: string
 /**
  * If `true`, the plugin will recursively search `root` for empty chunks and
  * remove them.
 */
removeEmptyChunks: boolean
}

const prefix = chalk.dim.cyan('cleanup-plugin')

/**
 * @private
 *
 * Pattern for matching empty chunks generated by Vite.
 */
const EMPTY_CHUNK_PATTERN = /^\n\/\/# sourceMappingURL=.*\n$/g

/**
 * Responsible for performing cleanup tasks at the end of a build.
 */
export default function cleanupPlugin(options: CleanupPluginOptions): Plugin {
  const emittedFiles: Array<string> = []

  /**
   * When a TypeScript source file only exports types, Rollup creates a .d.ts
   * file in the output directory, but it also creates an empty .js file. This
   * utility scans the configured `root` for these empty files and removes them.
   */
  const removeEmptyChunks = async () =>  Promise.all(emittedFiles.map(async filePath => {
    const fileContents = await fs.readFile(filePath, 'utf8')
    const isEmptyChunk = EMPTY_CHUNK_PATTERN.test(fileContents)
    if (isEmptyChunk) {
      await fs.remove(filePath)
      log.verbose(prefix, 'Removed empty chunk:', chalk.green(path.relative(options.root, filePath)))
    }
  }))

  return {
    name: 'ts:cleanup-plugin',
    enforce: 'post',
    generateBundle: (outputOptions, bundle) => {
      const filePath = outputOptions.dir ?? outputOptions.file ?? ''
      for (const fileName of Object.keys(bundle)) {
        emittedFiles.push(path.join(filePath, fileName))
      }
    },
    async closeBundle() {
      try {
        if (options.removeEmptyChunks) await removeEmptyChunks()
      } catch (err: any) {
        this.error(err)
      }
    }
  }
}