import chalk from 'chalk'

import log from './log'

import type { OutputBundle } from 'rollup'
import type { Plugin } from 'vite'

interface CleanupPluginOptions {
  /**
   * Root directory that the plugin will operate on. This should be set to the
   * project's output directory.
   */
  root: string
  /**
   * If `true`, the plugin will recursively search `root` for empty chunks and
   * remove them.
   */
  removeEmptyChunks: boolean
}

const prefix = chalk.dim.cyan('cleanup-plugin')

/**
 * @private
 *
 * Pattern for matching empty chunks generated by Vite.
 */
const EMPTY_CHUNK_PATTERN = /^\s*\/\/# sourceMappingURL=.*\s*$/

/**
 * @private
 *
 * Checks if a chunk's code matches the empty chunk pattern.
 */
const isEmptyChunkCode = (code: string): boolean => {
  if (!code) return false

  // Trim whitespace for comparison
  const trimmedCode = code.trim()

  // Check if the trimmed code matches the pattern
  return EMPTY_CHUNK_PATTERN.test(trimmedCode)
}

/**
 * @private
 *
 * Removes empty chunks from the output bundle.
 */
function removeEmptyChunks(bundle: OutputBundle) {
  for (const [fileName, chunk] of Object.entries(bundle)) {
    if (chunk.type !== 'chunk' || !fileName.endsWith('.js')) continue

    if (isEmptyChunkCode(chunk.code)) {
      Reflect.deleteProperty(bundle, fileName)
      log.verbose(prefix, 'Prevented empty chunk from being emitted:', chalk.green(fileName))

      const mapFileName = `${fileName}.map`

      if (bundle[mapFileName]) {
        Reflect.deleteProperty(bundle, mapFileName)
        log.verbose(prefix, 'Prevented empty chunk source map from being emitted:', chalk.green(mapFileName))
      }
    }
  }
}

/**
 * Responsible for performing cleanup tasks during and after a build.
 */
export default function cleanupPlugin(options: CleanupPluginOptions): Plugin {
  return {
    name: 'ts:cleanup-plugin',
    enforce: 'post',
    generateBundle: (outputOptions, bundle: OutputBundle) => {
      if (options.removeEmptyChunks) removeEmptyChunks(bundle)
    }
  }
}